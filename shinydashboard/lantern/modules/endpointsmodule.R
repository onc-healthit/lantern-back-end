library(DT)
library(purrr)
library(reactable)
library(glue)

endpointsmodule_UI <- function(id) {

  ns <- NS(id)

  tagList(
    fluidRow(
      column(width = 12, style = "padding-bottom:20px",
             h2(style = "margin-top:0", textOutput(ns("endpoint_count"))),
             downloadButton(ns("download_data"), "Download Endpoint Data (CSV)", icon = tags$i(class = "fa fa-download", "aria-hidden" = "true", role = "presentation", "aria-label" = "download icon")),
             downloadButton(ns("download_descriptions"), "Download Field Descriptions (CSV)", icon = tags$i(class = "fa fa-download", "aria-hidden" = "true", role = "presentation", "aria-label" = "download icon")),
             htmlOutput(ns("anchorlink"))
      ),
    ),
    tags$p("The URL for each endpoint in the table below can be clicked on to see additional information for that individual endpoint.", role = "comment"),
    reactable::reactableOutput(ns("endpoints_table")),
    tags$p("* An asterisk after a 'true' value in the 'Capability Statement Returned' field indicates that the returned Capability Statement for the endpoint is not of kind 'instance', which is the kind Lantern expects.", role = "comment"),
    htmlOutput(ns("note_text"))
  )
}

endpointsmodule <- function(
  input,
  output,
  session,
  sel_fhir_version,
  sel_vendor,
  sel_availability,
  sel_is_chpl
) {
  ns <- session$ns

  output$anchorlink <- renderUI({
    HTML("<p>You may also download endpoint data over time in the JSON format by visiting the <a tabindex=\"0\" id=\"downloads_page_link\" class=\"lantern-url\">Downloads Page</a>.</p>")
  })

  output$endpoint_count <- renderText({
    paste("Matching Endpoints:", nrow(selected_fhir_endpoints() %>% distinct(url, fhir_version)))
  })

selected_fhir_endpoints <- reactive({
    # Ensure all required reactive values are available
    req(sel_fhir_version())
    req(sel_vendor())
    req(sel_availability())
    req(sel_is_chpl())
    
    query_str <- "SELECT * FROM selected_fhir_endpoints_mv WHERE fhir_version IN ({vals*})"
    params <- list(vals = sel_fhir_version())

    if (sel_vendor() != ui_special_values$ALL_DEVELOPERS) {
        query_str <- paste0(query_str, " AND vendor_name = {vendor}")
        params$vendor <- sel_vendor()
    }

    if (sel_is_chpl() != "All") {
        query_str <- paste0(query_str, " AND is_chpl = {chpl}")
        params$chpl <- toupper(sel_is_chpl())
    }

    if (sel_availability() != "0-100") {
        if (sel_availability() == "0" || sel_availability() == "100") {
            query_str <- paste0(query_str, " AND availability = {availability}")
            params$availability <- as.numeric(sel_availability())
        } else {
            availability_range <- strsplit(sel_availability(), "-")[[1]]
            query_str <- paste0(query_str, " AND availability BETWEEN {low} AND {high}")
            params$low <- as.numeric(availability_range[1])
            params$high <- as.numeric(availability_range[2])
        }
    }

    query <- do.call(glue_sql, c(list(query_str, .con = db_connection), params))
    res <- tbl(db_connection, sql(query)) %>% collect()
    res
})

  # Downloadable csv of selected dataset
  output$download_data <- downloadHandler(
    filename = function() {
      "fhir_endpoints.csv"
    },
    content = function(file) {
      write.csv(csv_format(), file, row.names = FALSE)
    }
  )

  # Download csv of the field descriptions in the dataset csv
  output$download_descriptions <- downloadHandler(
    filename = function() {
      "fhir_endpoints_fields.csv"
    },
    content = function(file) {
      file.copy("fhir_endpoints_fields.csv", file)
    }
  )

  output$endpoints_table <- reactable::renderReactable({
     reactable(
              selected_fhir_endpoints() %>% select(urlModal, condensed_endpoint_names, endpoint_names, vendor_name, capability_fhir_version, format, cap_stat_exists, status, availability) %>% distinct(urlModal, condensed_endpoint_names, endpoint_names, vendor_name, capability_fhir_version, format, cap_stat_exists, status, availability) %>% group_by(urlModal) %>% mutate_all(as.character),
              defaultColDef = colDef(
                align = "center"
              ),
              columns = list(
                  urlModal = colDef(name = "URL", minWidth = 300,
                            style = JS("function(rowInfo, colInfo, state) {
                                    var prevRow = state.pageRows[rowInfo.viewIndex - 1]
                                    if (prevRow && rowInfo.row['urlModal'] === prevRow['urlModal']) {
                                      return { visibility: 'hidden' }
                                    }
                                  }"
                            ),
                            sortable = TRUE,
                            align = "left",
                            html = TRUE),
                  endpoint_names = colDef(show = FALSE),
                  condensed_endpoint_names = colDef(name = "API Information Source Name", minWidth = 200, sortable = FALSE, html = TRUE),
                  vendor_name = colDef(name = "Certified API Developer Name", minWidth = 110, sortable = FALSE),
                  capability_fhir_version = colDef(name = "FHIR Version", sortable = FALSE),
                  format = colDef(name = "Supported Formats", sortable = FALSE),
                  cap_stat_exists = colDef(name = "Capability Statement Returned", sortable = FALSE),
                  status = colDef(name = "HTTP Response", sortable = FALSE),
                  availability = colDef(name = "Availability", sortable = FALSE)
              ),
              searchable = TRUE,
              showSortIcon = TRUE,
              highlight = TRUE,
              defaultPageSize = 10
     )
  })

  # Create the format for the csv
  csv_format <- reactive({
    res <- selected_fhir_endpoints() %>%
      select(-id, -status, -availability, -fhir_version, -urlModal, -condensed_endpoint_names) %>%
      rowwise() %>%
      mutate(endpoint_names = ifelse(length(strsplit(endpoint_names, ";")[[1]]) > 100, paste0("Subset of Organizations, see Lantern Website for full list:", paste0(head(strsplit(endpoint_names, ";")[[1]], 100), collapse = ";")), endpoint_names)) %>%
      ungroup() %>%
      rename(api_information_source_name = endpoint_names, certified_api_developer_name = vendor_name) %>%
      rename(created_at = info_created, updated = info_updated) %>%
      rename(http_response_time_second = response_time_seconds)
  })

  output$note_text <- renderUI({
    note_info <- "The endpoints queried by Lantern are limited to Fast Healthcare Interoperability
      Resources (FHIR) endpoints published publicly by Certified API Developers in conformance
      with the ONC Cures Act Final Rule, or discovered through the National Plan and Provider
      Enumeration System (NPPES). This data, therefore, may not represent all FHIR endpoints
      in existence. Insights gathered from this data should be framed accordingly."
    res <- paste("<div style='font-size: 18px;'><b>Note:</b>", note_info, "</div>")
    HTML(res)
  })

}
